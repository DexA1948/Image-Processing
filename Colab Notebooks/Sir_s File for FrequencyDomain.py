# -*- coding: utf-8 -*-
"""IP_part-1-Image-Enhancement.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pgMWCk4SiL_22zxeN8eoBCEDmRp_DYrA
"""

def sum(a,b):
  return a+b

sum(2,3)

class Calculator:
  def __init__(self,a,b):
    self.a=a
    self.b=b
  def sum(self):
    return self.a+self.b
  def subtract(self):
    return self.b=-self.a


java =>

cal=Calculator(2,8)

a={"a":2,"b":"nitesh"}

type(a)

cal.sum()

"""polygon:- traingle,sqaure,hexagoon=>area premiter"""

class polygon=> feature variable l, b function/method()sum()

object is empty this.

!pip install numpy

a=[1,2,3,4]

type(a)

import numpy as np

x=np.array([1,2,3])

type(x)

x.shape

x.reshape(1,3,1)

!pip install -q -U opencv-python

!pip uninstall imgaug

# ==========end==========================image Enhancement and Edge Detection=================================

import numpy as np
import cv2
from google.colab.patches import cv2_imshow

image = cv2.imread("/content/drive/My Drive/cat.jpg")

type(image)

cv2_imshow(image)

image



image.shape

# x=np.array([1,2,3])

# x.shape

# x=np.array([[[1,2,3],[2,3,4],[3,4,5]],[[10,20,3],[2,30,4],[3,40,50]]])

# x.shape

# 0 => black 1=> - 255=> white

image_gray=cv2.cvtColor(image,cv2.COLOR_BGR2GRAY)

image_gray.shape

image_gray

cv2_imshow(image_gray)

image_bw= cv2.bitwise_not(image_gray)

image_bw

cv2_imshow(image_bw)

image_edge=cv2.Canny(image_gray,100,250)

# image_edge=cv2.Canny



cv2_imshow(image_edge)

# ================================thresholding=================================

image = cv2.imread("/content/drive/My Drive/cat.jpg",0)

cv2_imshow(image)

image

(thresh, blackAndWhiteImage) = cv2.threshold(image, 127, 185, cv2.THRESH_BINARY)

cv2_imshow(blackAndWhiteImage)

blackAndWhiteImage

img = cv2.imread('/content/drive/MyDrive/book.jpg')

cv2_imshow(img)

retval, threshold = cv2.threshold(img, 12, 255, cv2.THRESH_BINARY)
cv2_imshow(img)
cv2_imshow(threshold)

grayscaled = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
retval, threshold = cv2.threshold(grayscaled, 10, 255, cv2.THRESH_BINARY)
cv2_imshow(img)
cv2_imshow(threshold)

th = cv2.adaptiveThreshold(grayscaled, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 115, 1)
cv2_imshow(img)
cv2_imshow(th)

# ===============================================contrast Stretching==============================

img = cv2.imread('/content/drive/MyDrive/contrast.png',0)

cv2_imshow(img)

img.min()

img.max()

img_contrast=img.copy()

img.shape

# img_contrast=np.empty().reshape(161,163)
for i in range (img.shape[0]): #traverses through height of the image
    for j in range (img.shape[1]): #traverses through width of the image
        if img[i][j]==img.max():
          img_contrast[i][j]=255
        elif img[i][j]==img.min():
          img_contrast[i][j]=0
        else:
          img_contrast[i][j]==img[i][j]

img_contrast

cv2_imshow(img_contrast)

img_contrast.min()

img_contrast.max()

messi = cv2.imread('/content/drive/MyDrive/messi.png')

cv2_imshow(messi)

messi.max()

messi

messi.min()

import numpy as np

xp = [0, 64, 128, 192, 255]
fp = [0, 16, 128, 192, 255]
x = np.arange(256)
table = np.interp(x, xp, fp).astype('uint8')
img_contrast_1 = cv2.LUT(messi, table)

# img_contrast_1

cv2_imshow(img_contrast_1)

# ==========================================Intensity/Gray Level Slicing first approach========================

intensity_level = cv2.imread('/content/drive/MyDrive/intensity_level.png',0)

cv2_imshow(intensity_level)

intensity_level

in_lvl=intensity_level.copy()

intensity_level.shape

for i in range (intensity_level.shape[0]): #traverses through height of the image
    for j in range (intensity_level.shape[1]): #traverses through width of the image
        if intensity_level[i][j] in range(165,250):
          in_lvl[i][j]=0
        else:
          in_lvl[i][j]=255

cv2_imshow(in_lvl)

# ==========================================Intensity/Gray Level Slicing second approach========================

for i in range (intensity_level.shape[0]): #traverses through height of the image
    for j in range (intensity_level.shape[1]): #traverses through width of the image
        if intensity_level[i][j] in range(165,250):
          in_lvl[i][j]=0
        else:
          in_lvl[i][j]=intensity_level[i][j]

cv2_imshow(in_lvl)

# ========================================================Bit Plane Slicing====================================

img = cv2.imread('/content/drive/MyDrive/bit_plane.png',0)

img

img.shape

#Iterate over each pixel and change pixel value to binary using np.binary_repr() and store it in a list.
lst = []
for i in range(img.shape[0]):
    for j in range(img.shape[1]):
         lst.append(np.binary_repr(img[i][j] ,width=8)) # width = no. of bits

# We have a list of strings where each string represents binary pixel value. To extract bit planes we need to iterate over the strings and store the characters corresponding to bit planes into lists.
# Multiply with 2^(n-1) and reshape to reconstruct the bit image.
eight_bit_img = (np.array([int(i[0]) for i in lst],dtype = np.uint8) * 128).reshape(img.shape[0],img.shape[1])
seven_bit_img = (np.array([int(i[1]) for i in lst],dtype = np.uint8) * 64).reshape(img.shape[0],img.shape[1])
six_bit_img = (np.array([int(i[2]) for i in lst],dtype = np.uint8) * 32).reshape(img.shape[0],img.shape[1])
five_bit_img = (np.array([int(i[3]) for i in lst],dtype = np.uint8) * 16).reshape(img.shape[0],img.shape[1])
four_bit_img = (np.array([int(i[4]) for i in lst],dtype = np.uint8) * 8).reshape(img.shape[0],img.shape[1])
three_bit_img = (np.array([int(i[5]) for i in lst],dtype = np.uint8) * 4).reshape(img.shape[0],img.shape[1])
two_bit_img = (np.array([int(i[6]) for i in lst],dtype = np.uint8) * 2).reshape(img.shape[0],img.shape[1])
one_bit_img = (np.array([int(i[7]) for i in lst],dtype = np.uint8) * 1).reshape(img.shape[0],img.shape[1])

#Concatenate these images for ease of display using cv2.hconcat()
finalr = cv2.hconcat([eight_bit_img,seven_bit_img,six_bit_img,five_bit_img])
finalv =cv2.hconcat([four_bit_img,three_bit_img,two_bit_img,one_bit_img])

# Vertically concatenate
final = cv2.vconcat([finalr,finalv])

# Display the images
cv2_imshow(final)

lst = []
for i in range(img.shape[0]):
    for j in range(img.shape[1]):
         lst.append(np.binary_repr(img[i][j] ,width=8))

# lst[297]

11111111

for i in lst[1]:
  print(i[0])

lst[0]

11111111 =>2^8==>256  => 128 >0000000=>1000000=>



11111111 => 2^7=>128 => 2^6 => 64

11111111

new_img = eight_bit_img+seven_bit_img+six_bit_img+five_bit_img

cv2_imshow(new_img)

cv2_imshow(img)

# ========================================Histogram Plot============================================================

# ===========for gray levels========================================

import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
import cv2
import numpy as np

img = cv2.imread('/content/drive/MyDrive/sliding.png',0)

cv2_imshow(img)

hist = cv2.calcHist([img],[0],None,[256],[0,256])

plt.plot(hist)

# ===========for rgb levels========================================

img = cv2.imread('/content/drive/MyDrive/color.jpg')

# img

cv2_imshow(img)

color = ('b','g','r')
for i,col in enumerate(color):
    histr = cv2.calcHist([img],[i],None,[256],[0,256])
    plt.plot(histr,color = col)

# ========================================Histogram Sliding============================================================

# =====================sliding to right(increase brightness)==================================

img = cv2.imread('/content/drive/MyDrive/sliding.png',0)

cv2_imshow(img)

histr = cv2.calcHist([img],[0],None,[256],[0,256])
plt.plot(histr)

img_slide_right=img.copy()

for i in range (img.shape[0]): #traverses through height of the image
    for j in range (img.shape[1]): #traverses through width of the image
          img_slide_right[i][j]=img[i][j]+50

cv2_imshow(img_slide_right)

histr = cv2.calcHist([img_slide_right],[0],None,[256],[0,256])
plt.plot(histr)
# plt.xlim([0,256])
# plt.ylim([0,2000])

# =====================sliding to left(decrease brightness)==================================

img_slide_left=img.copy()

for i in range (img.shape[0]): #traverses through height of the image
    for j in range (img.shape[1]): #traverses through width of the image
          if(img[i][j]-50) >=0:
            img_slide_left[i][j]=img[i][j]-50
          else:
            img_slide_left[i][j]=0

cv2_imshow(img_slide_left)

histr = cv2.calcHist([img_slide_left],[0],None,[256],[0,256])
plt.plot(histr)
plt.xlim([0,256])
plt.ylim([0,2000])

# ========================histogram Stretching or histogram normalization for contrast==========================

# Contrast is the difference between maximum and minimum pixel intensity.

img = cv2.imread('/content/drive/MyDrive/his_contrast.png',0)

cv2_imshow(img)

img.min()

img.max()

histr = cv2.calcHist([img],[0],None,[256],[0,256])
plt.plot(histr)

img_contrast= img.copy()

for i in range(img.shape[0]):
    for j in range(img.shape[1]):
        img_contrast[i,j] = 255*(img[i,j]-np.min(img))/(np.max(img)-np.min(img))

cv2_imshow(img_contrast)

histr = cv2.calcHist([img_contrast],[0],None,[256],[0,256])
plt.plot(histr)

img_contrast.min()

img_contrast.max()

# =========================================histogram equalization for enhance contrast and eualize the occurency of pixels graylevel =======================================

# Histogram Equalization is an image processing technique that adjusts the contrast of an image by using its histogram. 
# To enhance the image's contrast, it spreads out the most frequent pixel intensity values or stretches out the intensity range of the image.

import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
import cv2
import numpy as np

img = cv2.imread('/content/drive/MyDrive/his_contrast.png',0)

cv2_imshow(img)

histr = cv2.calcHist([img],[0],None,[256],[0,256])
plt.plot(histr)

dst = cv2.equalizeHist(img)

cv2_imshow(dst)

# =================================sine and cosine=============================================

import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
import cv2
import numpy as np

x = np.arange(0,4*np.pi,0.1)   # start,stop,step
y = np.sin(x)
y1 = np.cos(x)

x

y

y1

plt.plot(x,y)

plt.plot(x,y1)

b



# ====================================================Frequency domain filter====================================================

#==============================convert spatial image to frequency spectrum using FFT==========================================

# ==================FFT is 100 to 600 times faster than DFT=======================================

# =========================image on frequency domain => frequency spectrum(amplitude) + phase spectrum(angle or direction)===================================

import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab.patches import cv2_imshow
from math import sqrt,exp

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)

cv2_imshow(img)

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)
plt.figure(figsize=(6.4*5, 4.8*5), constrained_layout=False)

original = np.fft.fft2(img)
plt.subplot(131), plt.imshow(np.log(np.abs(original)), "gray"), plt.title("Spectrum")

plt.subplot(132), plt.imshow(np.angle(original), "gray"), plt.title("Phase Angle")
plt.show()

original

img

# np.log(np.abs(original))

# np.angle(original)

# ===============================steps for doing filter in frequency domain using FFT=======================

# Load the image
# Compute the 2-dimensional Fast Fourier Transform.
# Shift the high/zero-frequency component to the center of the spectrum.
# Shift the zero-frequency component back to original location (inverse transform)
# Compute the 2-dimensional inverse Fast Fourier Transform. (inverse transform)



img_c1 = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)

img_c2 = np.fft.fft2(img_c1)
img_c3 = np.fft.fftshift(img_c2)
img_c4 = np.fft.ifftshift(img_c3)
img_c5 = np.fft.ifft2(img_c4)

plt.figure(figsize=(6.4*5, 4.8*5), constrained_layout=False)

plt.subplot(151), plt.imshow(img_c1, "gray"), plt.title("Original Image")
plt.subplot(152), plt.imshow(np.log(1+np.abs(img_c2)), "gray"), plt.title("Spectrum")
plt.subplot(153), plt.imshow(np.log(1+np.abs(img_c3)), "gray"), plt.title("Centered Spectrum")
plt.subplot(154), plt.imshow(np.log(1+np.abs(img_c4)), "gray"), plt.title("Decentralized")
plt.subplot(155), plt.imshow(np.abs(img_c5), "gray"), plt.title("Processed Image")

img_c1

np.abs(img_c5)

# ====================================ideal low pass and high pass filter======================================



def distance(point1,point2):
    return sqrt((point1[0]-point2[0])**2 + (point1[1]-point2[1])**2)

def idealFilterLP(D0,imgShape):
    base = np.zeros(imgShape[:2])
    rows, cols = imgShape[:2]
    center = (rows/2,cols/2)
    for x in range(cols):
        for y in range(rows):
            if distance((y,x),center) < D0:
                base[y,x] = 1
    return base

def idealFilterHP(D0,imgShape):
    base = np.ones(imgShape[:2])
    rows, cols = imgShape[:2]
    center = (rows/2,cols/2)
    for x in range(cols):
        for y in range(rows):
            if distance((y,x),center) < D0:
                base[y,x] = 0
    return base

plt.figure(figsize=(6.4*5, 4.8*5), constrained_layout=False)
img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)

LowPass = idealFilterLP(50,img.shape)
plt.subplot(131), plt.imshow(LowPass, "gray"), plt.title("Ideal Low Pass Filter")

HighPass = idealFilterHP(50,img.shape)
plt.subplot(132), plt.imshow(HighPass, "gray"), plt.title("Ideal High Pass Filter")

plt.show()



# imgShape[:2] => all columns:all rows

# ======================ideal low pass filter=========================

plt.figure(figsize=(6.4*6, 4.8*6), constrained_layout=False)

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)
plt.subplot(171), plt.imshow(img, "gray"), plt.title("Original Image")

original = np.fft.fft2(img)
plt.subplot(172), plt.imshow(np.log(1+np.abs(original)), "gray"), plt.title("Spectrum")

center = np.fft.fftshift(original)
plt.subplot(173), plt.imshow(np.log(1+np.abs(center)), "gray"), plt.title("Centered Spectrum")

lowPassFilter = idealFilterLP(50,img.shape)
plt.subplot(174), plt.imshow(np.log(1+np.abs(lowPassFilter)), "gray"), plt.title("Low Pass Filter")

LowPassCenter = center * idealFilterLP(50,img.shape)
plt.subplot(175), plt.imshow(np.log(1+np.abs(LowPassCenter)), "gray"), plt.title("Centered Spectrum multiply Low Pass Filter")

LowPass = np.fft.ifftshift(LowPassCenter)
plt.subplot(176), plt.imshow(np.log(1+np.abs(LowPass)), "gray"), plt.title("Decentralize")

inverse_LowPass = np.fft.ifft2(LowPass)
plt.subplot(177), plt.imshow(np.abs(inverse_LowPass), "gray"), plt.title("Processed Image")

plt.show()

G(u,v)=H(u,v)F(u,v)

# ================================================ideal high pass filter==========================

plt.figure(figsize=(6.4*6, 4.8*6), constrained_layout=False)

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)
plt.subplot(171), plt.imshow(img, "gray"), plt.title("Original Image")

original = np.fft.fft2(img)
plt.subplot(172), plt.imshow(np.log(1+np.abs(original)), "gray"), plt.title("Spectrum")

center = np.fft.fftshift(original)
plt.subplot(173), plt.imshow(np.log(1+np.abs(center)), "gray"), plt.title("Centered Spectrum")

highPassFilter = idealFilterHP(50,img.shape)
plt.subplot(174), plt.imshow(np.log(1+np.abs(highPassFilter)), "gray"), plt.title("High Pass Filter")

HighPassCenter = center * idealFilterHP(50,img.shape)
plt.subplot(175), plt.imshow(np.log(1+np.abs(HighPassCenter)), "gray"), plt.title("Centered Spectrum multiply High Pass Filter")

HighPass = np.fft.ifftshift(HighPassCenter)
plt.subplot(176), plt.imshow(np.log(1+np.abs(HighPass)), "gray"), plt.title("Decentralize")

inverse_HighPass = np.fft.ifft2(HighPass)
plt.subplot(177), plt.imshow(np.abs(inverse_HighPass), "gray"), plt.title("Processed Image")

plt.show()

# ===================================================butterworths filter lowpass and high pass==================================

def distance(point1,point2):
    return sqrt((point1[0]-point2[0])**2 + (point1[1]-point2[1])**2)

def butterworthLP(D0,imgShape,n):
    base = np.zeros(imgShape[:2])
    rows, cols = imgShape[:2]
    center = (rows/2,cols/2)
    for x in range(cols):
        for y in range(rows):
            base[y,x] = 1/(1+(distance((y,x),center)/D0)**(2*n))
    return base

def butterworthHP(D0,imgShape,n):
    base = np.zeros(imgShape[:2])
    rows, cols = imgShape[:2]
    center = (rows/2,cols/2)
    for x in range(cols):
        for y in range(rows):
            base[y,x] = 1-1/(1+(distance((y,x),center)/D0)**(2*n))
    return base

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)

plt.figure(figsize=(6.4*5, 4.8*5), constrained_layout=False)

LowPass = butterworthLP(50,img.shape,20)
plt.subplot(131), plt.imshow(LowPass, "gray"), plt.title("Butterworth Low Pass Filter (n=20)")

HighPass = butterworthHP(50,img.shape,20)
plt.subplot(132), plt.imshow(HighPass, "gray"), plt.title("Butterworth High Pass Filter (n=20)")

plt.show()

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)
plt.figure(figsize=(6.4*5, 4.8*5), constrained_layout=False)

LowPass = butterworthLP(50,img.shape,3)
plt.subplot(131), plt.imshow(LowPass, "gray"), plt.title("Butterworth Low Pass Filter (n=3)")

HighPass = butterworthHP(50,img.shape,3)
plt.subplot(132), plt.imshow(HighPass, "gray"), plt.title("Butterworth High Pass Filter (n=3)")

plt.show()

# ===============================butterworth low pass filter=====================================

plt.figure(figsize=(6.4*6, 4.8*6), constrained_layout=False)

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)
plt.subplot(171), plt.imshow(img, "gray"), plt.title("Original Image")

original = np.fft.fft2(img)
plt.subplot(172), plt.imshow(np.log(1+np.abs(original)), "gray"), plt.title("Spectrum")

center = np.fft.fftshift(original)
plt.subplot(173), plt.imshow(np.log(1+np.abs(center)), "gray"), plt.title("Centered Spectrum")

butterworthLowPassFilter = butterworthLP(50,img.shape,3)
plt.subplot(174), plt.imshow(np.log(1+np.abs(butterworthLowPassFilter)), "gray"), plt.title("Butterworth Low Pass Filter (n=3)")

butterworthLowPassCenter = center * butterworthLP(50,img.shape,3)
plt.subplot(175), plt.imshow(np.log(1+np.abs(butterworthLowPassCenter)), "gray"), plt.title("Centered Spectrum multiply Butterworth Low Pass Filter (n=3)")

butterworthLowPass = np.fft.ifftshift(butterworthLowPassCenter)
plt.subplot(176), plt.imshow(np.log(1+np.abs(butterworthLowPass)), "gray"), plt.title("Decentralize")

inverse_butterworthLowPass = np.fft.ifft2(butterworthLowPass)
plt.subplot(177), plt.imshow(np.abs(inverse_butterworthLowPass), "gray"), plt.title("Processed Image")

plt.show()

# ========================================buttterworth high pass filter========================================

plt.figure(figsize=(6.4*6, 4.8*6), constrained_layout=False)

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)
plt.subplot(171), plt.imshow(img, "gray"), plt.title("Original Image")

original = np.fft.fft2(img)
plt.subplot(172), plt.imshow(np.log(1+np.abs(original)), "gray"), plt.title("Spectrum")

center = np.fft.fftshift(original)
plt.subplot(173), plt.imshow(np.log(1+np.abs(center)), "gray"), plt.title("Centered Spectrum")

butterworthHighPassFilter = butterworthHP(50,img.shape,3)
plt.subplot(174), plt.imshow(np.log(1+np.abs(butterworthHighPassFilter)), "gray"), plt.title("Butterworth High Pass Filter (n=3)")

butterworthHighPassCenter = center * butterworthHP(50,img.shape,3)
plt.subplot(175), plt.imshow(np.log(1+np.abs(butterworthHighPassCenter)), "gray"), plt.title("Centered Spectrum multiply Butterworth High Pass Filter (n=3)")

butterworthHighPass = np.fft.ifftshift(butterworthHighPassCenter)
plt.subplot(176), plt.imshow(np.log(1+np.abs(butterworthHighPass)), "gray"), plt.title("Decentralize")

inverse_butterworthHighPass = np.fft.ifft2(butterworthHighPass)
plt.subplot(177), plt.imshow(np.abs(inverse_butterworthHighPass), "gray"), plt.title("Processed Image")

plt.show()

# ==================================================gaussian low and high pass filter==================================================

def gaussianLP(D0,imgShape):
    base = np.zeros(imgShape[:2])
    rows, cols = imgShape[:2]
    center = (rows/2,cols/2)
    for x in range(cols):
        for y in range(rows):
            base[y,x] = exp(((-distance((y,x),center)**2)/(2*(D0**2))))
    return base

def gaussianHP(D0,imgShape):
    base = np.zeros(imgShape[:2])
    rows, cols = imgShape[:2]
    center = (rows/2,cols/2)
    for x in range(cols):
        for y in range(rows):
            base[y,x] = 1 - exp(((-distance((y,x),center)**2)/(2*(D0**2))))
    return base

plt.figure(figsize=(6.4*5, 4.8*5), constrained_layout=False)

LowPass = gaussianLP(50,img.shape)
plt.subplot(131), plt.imshow(LowPass, "gray"), plt.title("Gaussian Low Pass Filter")

HighPass = gaussianHP(50,img.shape)
plt.subplot(132), plt.imshow(HighPass, "gray"), plt.title("Gaussian High Pass Filter")

plt.show()

# ===============================gaussian low pass filter=====================================

plt.figure(figsize=(6.4*6, 4.8*6), constrained_layout=False)

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)
plt.subplot(171), plt.imshow(img, "gray"), plt.title("Original Image")

original = np.fft.fft2(img)
plt.subplot(172), plt.imshow(np.log(1+np.abs(original)), "gray"), plt.title("Spectrum")

center = np.fft.fftshift(original)
plt.subplot(173), plt.imshow(np.log(1+np.abs(center)), "gray"), plt.title("Centered Spectrum")

gaussianLowPassFilter = gaussianLP(50,img.shape)
plt.subplot(174), plt.imshow(np.log(1+np.abs(gaussianLowPassFilter)), "gray"), plt.title("Gaussian Low Pass Filter")

gaussianLowPassCenter = center * gaussianLP(50,img.shape)
plt.subplot(175), plt.imshow(np.log(1+np.abs(gaussianLowPassCenter)), "gray"), plt.title("Centered Spectrum multiply Gaussian Low Pass Filter")

gaussianLowPass = np.fft.ifftshift(gaussianLowPassCenter)
plt.subplot(176), plt.imshow(np.log(1+np.abs(gaussianLowPass)), "gray"), plt.title("Decentralize")

inverse_gaussianLowPass = np.fft.ifft2(gaussianLowPass)
plt.subplot(177), plt.imshow(np.abs(inverse_gaussianLowPass), "gray"), plt.title("Processed Image")

plt.show()

# ===============================gaussian high pass filter=====================================

plt.figure(figsize=(6.4*6, 4.8*6), constrained_layout=False)

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)
plt.subplot(171), plt.imshow(img, "gray"), plt.title("Original Image")

original = np.fft.fft2(img)
plt.subplot(172), plt.imshow(np.log(1+np.abs(original)), "gray"), plt.title("Spectrum")

center = np.fft.fftshift(original)
plt.subplot(173), plt.imshow(np.log(1+np.abs(center)), "gray"), plt.title("Centered Spectrum")

gaussianHighPassFilter = gaussianHP(50,img.shape)
plt.subplot(174), plt.imshow(np.log(1+np.abs(gaussianHighPassFilter)), "gray"), plt.title("Gaussian High Pass Filter")

gaussianHighPassCenter = center * gaussianHP(50,img.shape)
plt.subplot(175), plt.imshow(np.log(1+np.abs(gaussianHighPassCenter)), "gray"), plt.title("Centered Spectrum multiply Gaussian High Pass Filter")

gaussianHighPass = np.fft.ifftshift(gaussianHighPassCenter)
plt.subplot(176), plt.imshow(np.log(1+np.abs(gaussianHighPass)), "gray"), plt.title("Decentralize")

inverse_gaussianHighPass = np.fft.ifft2(gaussianHighPass)
plt.subplot(177), plt.imshow(np.abs(inverse_gaussianHighPass), "gray"), plt.title("Processed Image")

plt.show()

# =======================================comparision between ideal, butterworths and gaussian filter=======================================

plt.figure(figsize=(6.4*5, 4.8*5), constrained_layout=False)
img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)

IdealLP = idealFilterLP(50,img.shape)
plt.subplot(131), plt.imshow(IdealLP, "gray"), plt.title("Ideal Low Pass Filter")

ButterLP = butterworthLP(50,img.shape,10)
plt.subplot(132), plt.imshow(ButterLP, "gray"), plt.title("Butterworth Low Pass Filter (n=10)")

GaussianLP = gaussianLP(50,img.shape)
plt.subplot(133), plt.imshow(GaussianLP, "gray"), plt.title("Gaussian Low Pass Filter")

plt.figure(figsize=(6.4*5, 4.8*5), constrained_layout=False)
IdealHP = idealFilterHP(50,img.shape)
plt.subplot(231), plt.imshow(IdealHP, "gray"), plt.title("Ideal High Pass Filter")

ButterHP = butterworthHP(50,img.shape,10)
plt.subplot(232), plt.imshow(ButterHP, "gray"), plt.title("Butterworth High Pass Filter (n=10)")

GaussianHP = gaussianHP(50,img.shape)
plt.subplot(233), plt.imshow(GaussianHP, "gray"), plt.title("Gaussian High Pass Filter")

plt.show()

# =======================================comparision between ideal, butterworths and gaussian filter output image=======================================

#=====================low pass output comparision====================================

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)
original = np.fft.fft2(img)
center = np.fft.fftshift(original)

plt.figure(figsize=(6.4*5, 4.8*5), constrained_layout=False)

LowPassCenter = center * idealFilterLP(50,img.shape)
LowPass = np.fft.ifftshift(LowPassCenter)
inverse_LowPass = np.fft.ifft2(LowPass)
plt.subplot(131), plt.imshow(np.abs(inverse_LowPass), "gray"), plt.title("Ideal Low Pass")

LowPassCenter = center * butterworthLP(50,img.shape,10)
LowPass = np.fft.ifftshift(LowPassCenter)
inverse_LowPass = np.fft.ifft2(LowPass)
plt.subplot(132), plt.imshow(np.abs(inverse_LowPass), "gray"), plt.title("Butterworth Low Pass (n=10)")

LowPassCenter = center * gaussianLP(50,img.shape)
LowPass = np.fft.ifftshift(LowPassCenter)
inverse_LowPass = np.fft.ifft2(LowPass)
plt.subplot(133), plt.imshow(np.abs(inverse_LowPass), "gray"), plt.title("Gaussian Low Pass")

plt.show()

# note gaussian removes ring effect and is better than ideal and butterworths when removing noise in low pass

#=====================high pass output comparision====================================

img = cv2.imread("/content/drive/MyDrive/freq_filtration.png", 0)
original = np.fft.fft2(img)
center = np.fft.fftshift(original)

plt.figure(figsize=(6.4*5, 4.8*5), constrained_layout=False)

HighPassCenter = center * idealFilterHP(50,img.shape)
HighPass = np.fft.ifftshift(HighPassCenter)
inverse_HighPass = np.fft.ifft2(HighPass)
plt.subplot(131), plt.imshow(np.abs(inverse_HighPass), "gray"), plt.title("Ideal High Pass")

HighPassCenter = center * butterworthHP(50,img.shape,10)
HighPass = np.fft.ifftshift(HighPassCenter)
inverse_HighPass = np.fft.ifft2(HighPass)
plt.subplot(132), plt.imshow(np.abs(inverse_HighPass), "gray"), plt.title("Butterworth High Pass (n=10)")

HighPassCenter = center * gaussianHP(50,img.shape)
HighPass = np.fft.ifftshift(HighPassCenter)
inverse_HighPass = np.fft.ifft2(HighPass)
plt.subplot(133), plt.imshow(np.abs(inverse_HighPass), "gray"), plt.title("Gaussian High Pass")

plt.show()







